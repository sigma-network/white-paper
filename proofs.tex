\section{Zero knowledge proofs of validity}
\label{proofs}

We use zero knowledge proofs to demonstrate the validity of transactions, as well as other messages such as voter registration. In particular, we use the proof system described in \cite{katz2018improved}, which gives reasonable proof times and sizes for circuits with relatively small numbers of AND gates. The proof system, hash functions, and the other cryptographic primitives we use are all parameterized for 128 bit classical security.

[The proof system is subject to change. Need to evaluate zk-STARKs which purportedly were improved to ~80kb for a Zcash-like circuit? Also consider using zk-SNARKs for now, and transitioning to something else later if/when Shor's algorithm becomes more of a threat.]

The proofs described below all deal with \emph{notes}. A note is a message $\angled{\mathrm{pk}, n, s}$, where pk is the public key of the user who owns the note, $n$ is the number of coins which the note represents, and $s$ is a salt which is pseudorandomly generated by the user to sent the note.


\subsection{Spend circuit}
\label{spend-circuit}

Each transaction has one or two \emph{source} notes and zero, one or two \emph{destination} notes. The source notes are consumed by the transaction, while the destination notes are newly created. In order for a transaction to be valid, the combined amounts of the source notes must equal the combined amounts of the destination notes plus the transaction fee.

The spend circuit proves that a transaction is valid. We use a design similar to Zcash's \texttt{POUR} circuit. The circuit consumes one or two notes and produces one or two new notes. This lets users split one account into two, or combine two accounts into one, all without revealing which type of transaction they are performing.

To ensure that a note cannot be consumed twice, a ``nullifier'' associated with the note is exposed in the output layer. Validators keep track of all previous nullifiers, and reject any transactions whose nullifiers are already present in the nullifier set. An outsider cannot tell which nullifiers are associated with which commitments, but the circuit guarantees that a unique nullifier is produced for each commitment. Thus, we are able to prevent double spending without sacrificing privacy.

%\begin{figure}
%  \centering
%    \includegraphics[width=0.8\textwidth]{images/circuits/spend}
%  \caption{The structure of the spend circuit. Note that in the real circuit, there are two source notes and two destination notes, but we only depict one of each for the sake of brevity.}
%\end{figure}

Zcash stores all commitments in a Merkle tree of depth 64, using SHA-256 as the hash function. To validate that the commitments being consumed are actually present in the blockchain, the \texttt{POUR} circuit includes two Merkle proofs going all the way up to the Merkle root.

The SHA-256 circuit Zcash uses has 27,904 AND gates, and the entire \texttt{POUR} circuit has 4,109,330 AND gates.

[TODO: Explain our approach in detail. TLDR: We use LowMC-256 \cite{albrecht2015ciphers} + Davies-Meyer as the hash function. We use Merkle trees with a depth of 5, giving us an AND count of ~20k, and proof sizes well under 100kb. Our privacy guarantee is not as great as Zcash's, but better than Monero's; our default ring size is 32 compared to their default of 7. This is all tentative and subject to change.]


\subsection{Registration circuit}
\label{registration-circuit}

[TODO: Explain the circuit.]

[TODO: Add a graph to show the structure.]


\subsection{Vote circuit}
\label{vote-circuit}

[TODO: This should just be a simple signature? Preimage and message in the input layer, postimage in the output layer?]

[TODO: Add a graph to show the structure.]


\subsection{Block creation circuit}
\label{block-creation-circuit}

[TODO: This should just be a simple signature to show that a block was endorsed by the eligible block creator.]


\subsection{Performance}

[TODO: Add average case proof sizes, plus proof times and verification times.]
